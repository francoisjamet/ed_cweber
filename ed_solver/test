!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************

  SUBROUTINE write_cplx_array_rank_3(A,title,SHORT,UNIT)

    !$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
    !$$ WRITE COMPLEX ARRAY A(n1,n2,n3) $$
    !$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

    CHARACTER(LEN=*),               INTENT(IN) :: title
    COMPLEX(8), DIMENSION(:,:,:), INTENT(IN)   :: A
    LOGICAL,              INTENT(IN), OPTIONAL :: SHORT
    INTEGER,              INTENT(IN), OPTIONAL :: UNIT
    INTEGER                                    :: i1,i2,i3,n1,n2,n3,unit_
    LOGICAL                                    :: short_
    CHARACTER(LEN=400)                         :: fmt_A

                      unit_ = log_unit ! DEFAULT: STANDARD OUTPUT
    IF(PRESENT(UNIT)) unit_ = UNIT

    short_ = present(short)

    n1 = SIZE(A,1); n2 = SIZE(A,2); n3 = SIZE(A,3)

    CALL dump_message(UNIT=unit_,TEXT=title)

    IF(short_)THEN
      WRITE(fmt_A,*) '(',n1-1,'(',n3,'(',n2,'(2(a,f10.6),a,x),2x)/),',n3,'(',n2,'(2(a,f10.6),a,x),2x))'
    ELSE
      WRITE(fmt_A,*) '(',n1-1,'(',n3,'(',n2,'(2(a,f20.16),a,x),2x)/),',n3,'(',n2,'(2(a,f20.16),a,x),2x))'
    ENDIF

    WRITE(unit_,fmt_A) ((('(',DBLE(A(i1,i2,i3)),',',AIMAG(A(i1,i2,i3)),')',i2=1,n2),i3=1,n3),i1=1,n1)

    CALL flush(unit_)

  END SUBROUTINE 

!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************

  SUBROUTINE write_real_array_rank_3(A,title,SHORT,UNIT)

    !$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
    !$$ WRITE REAL ARRAY A(n1,n2,n3) $$
    !$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

    CHARACTER(LEN=*),               INTENT(IN) :: title
    REAL(8),    DIMENSION(:,:,:), INTENT(IN)   :: A
    LOGICAL,              INTENT(IN), OPTIONAL :: SHORT
    INTEGER,              INTENT(IN), OPTIONAL :: UNIT
    INTEGER                                    :: i1,i2,i3,n1,n2,n3,unit_
    LOGICAL                                    :: short_
    CHARACTER(LEN=400)                         :: fmt_A

    unit_ = log_unit ! DEFAULT: STANDARD OUTPUT
    IF(PRESENT(UNIT)) unit_ = UNIT

    short_ = present(short) 

    n1 = SIZE(A,1)
    n2 = SIZE(A,2)
    n3 = SIZE(A,3)

    CALL dump_message(UNIT=unit_,TEXT=title)

    IF(short_)THEN
      WRITE(fmt_A,*) '(',n1-1,'(',n3,'(',n2,'(f10.6,x),2x)/),',n3,'(',n2,'(f10.6,x),2x))'
    ELSE
      WRITE(fmt_A,*) '(',n1-1,'(',n3,'(',n2,'(f20.16,x),2x)/),',n3,'(',n2,'(f20.16,x),2x))'
    ENDIF
    WRITE(unit_,fmt_A) (((A(i1,i2,i3),i2=1,n2),i3=1,n3),i1=1,n1)

    CALL flush(unit_)
  END SUBROUTINE 

!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************


  SUBROUTINE write_intg_array_rank_3(A,title,UNIT)

    !$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
    !$$ WRITE INTEGER ARRAY A(n1,n2,n3) $$
    !$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

    CHARACTER(LEN=*),               INTENT(IN) :: title
    INTEGER,      DIMENSION(:,:,:), INTENT(IN) :: A
    INTEGER,              INTENT(IN), OPTIONAL :: UNIT
    INTEGER                                    :: i1,i2,i3,n1,n2,n3,unit_
    CHARACTER(LEN=1000)                        :: fmt_A

    unit_ = log_unit ! DEFAULT: STANDARD OUTPUT
    IF(PRESENT(UNIT)) unit_ = UNIT

    n1 = SIZE(A,1)
    n2 = SIZE(A,2)
    n3 = SIZE(A,3)

    CALL dump_message(UNIT=unit_,TEXT=title)

    WRITE(fmt_A,*) '(',n1-1,'(2x,',n3,'(',n2,'(I3,x),2x)/),2x,',n3,'(',n2,'(I3,x),2x))'
    WRITE(unit_,fmt_A) (((A(i1,i2,i3),i2=1,n2),i3=1,n3),i1=1,n1)

    CALL flush(unit_)
  END SUBROUTINE


!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************

  SUBROUTINE write_bool_array_rank_3(A,title,UNIT)

    !$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
    !$$ WRITE BOOLEAN ARRAY A(n1,n2,n3) $$
    !$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

    CHARACTER(LEN=*),               INTENT(IN)  :: title
    LOGICAL,      DIMENSION(:,:,:), INTENT(IN)  :: A
    INTEGER,              INTENT(IN), OPTIONAL  :: UNIT
    INTEGER                                     :: i1,i2,i3,n1,n2,n3,unit_
    CHARACTER(LEN=400)                          :: fmt_A

    unit_ = log_unit ! DEFAULT: STANDARD OUTPUT
    IF(PRESENT(UNIT)) unit_ = UNIT

    n1 = SIZE(A,1)
    n2 = SIZE(A,2)
    n3 = SIZE(A,3)

    CALL dump_message(UNIT=unit_,TEXT=title)

    WRITE(fmt_A,*) '(',n1-1,'(2x,',n3,'(',n2,'(L2,x),2x)/),',n3,'(2x,',n2,'(L2,x)))'
    WRITE(unit_,fmt_A) (((A(i1,i2,i3),i2=1,n2),i3=1,n3),i1=1,n1)

    CALL flush(unit_)
  END SUBROUTINE 

!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************


  SUBROUTINE write_cplx_array_rank_2(A,title,UNIT,SHORT,ULTRASHORT)

    !$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
    !$$ WRITE COMPLEX ARRAY A(n1,n2) $$
    !$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

    CHARACTER(LEN=*), INTENT(IN)           :: title
    COMPLEX(8),     INTENT(IN)             :: A(:,:)
    LOGICAL,          INTENT(IN), OPTIONAL :: SHORT,ULTRASHORT
    INTEGER,          INTENT(IN), OPTIONAL :: UNIT
    INTEGER                                :: i1,i2,n1,n2,unit_
    LOGICAL                                :: short_
    CHARACTER(LEN=400)                     :: fmt_A

    unit_ = log_unit ! DEFAULT: STANDARD OUTPUT
    IF(PRESENT(UNIT)) unit_ = UNIT

    short_ = present(short) 

    n1 = SIZE(A,1); n2 = SIZE(A,2)

    CALL dump_message(UNIT=unit_,TEXT=title)

    if(.not.present(ULTRASHORT))then
     IF(short_)THEN
      WRITE(fmt_A,*) '(',n2,'( 2f10.6))'
     ELSE
      WRITE(fmt_A,*) '(',n2,'( 2f20.10))'
     ENDIF
    else
      WRITE(fmt_A,*) '(',n2,'( 2f5.1))'
    endif

    WRITE(unit_,fmt_A,err=10) ((DBLE(A(i1,i2)),AIMAG(A(i1,i2)),i2=1,n2),i1=1,n1)
 10 continue
    CALL flush(unit_)

  END SUBROUTINE 

!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************

  SUBROUTINE write_real_array_rank_2(A,title,UNIT,SHORT,ULTRASHORT)

    !$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
    !$$ WRITE REAL ARRAY A(n1,n2) $$
    !$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

    CHARACTER(LEN=*),             INTENT(IN)           :: title
    REAL(8),    DIMENSION(:,:), INTENT(IN)             :: A
    LOGICAL,                      INTENT(IN), OPTIONAL :: SHORT,ULTRASHORT
    INTEGER,                      INTENT(IN), OPTIONAL :: UNIT
    INTEGER                                            :: i1,i2,n1,n2,unit_
    LOGICAL                                            :: short_
    CHARACTER(LEN=400)                                 :: fmt_A

    unit_ = log_unit ! STANDARD OUTPUT
    IF(PRESENT(UNIT)) unit_ = UNIT

    short_ = present(short)

    n1 = SIZE(A,1)
    n2 = SIZE(A,2)
    if(n1==1.and.n2==1) return

    CALL dump_message(UNIT=unit_,TEXT=title)

   if(.not.present(ULTRASHORT))then
    IF(short_)THEN
      WRITE(fmt_A,*) '(',n1-1,'(',n2,'(f10.6,x)/),',n2,'(f10.6,x))'
    ELSE
      WRITE(fmt_A,*) '(',n1-1,'(',n2,'(f20.16,x)/),',n2,'(f20.16,x))'
    ENDIF
   else
      WRITE(fmt_A,*) '(',n1-1,'(',n2,'(f5.1,x)/),',n2,'(f5.1,x))'
   endif

    WRITE(unit_,fmt_A) ((A(i1,i2),i2=1,n2),i1=1,n1)

    CALL flush(unit_)

  END SUBROUTINE 

!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************


  SUBROUTINE write_intg_array_rank_2(A,title,UNIT)

    !$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
    !$$ WRITE INTEGER ARRAY A(n1,n2) $$
    !$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

    CHARACTER(LEN=*),  INTENT(IN) :: title
    INTEGER,           INTENT(IN) :: A(:,:)
    INTEGER, OPTIONAL, INTENT(IN) :: UNIT
    INTEGER                       :: i1,i2,n1,n2,unit_
    CHARACTER(LEN=400)            :: fmt_A

    unit_ = log_unit ! STANDARD OUTPUT
    IF(PRESENT(UNIT)) unit_ = UNIT

    n1 = SIZE(A,1)
    n2 = SIZE(A,2)

    CALL dump_message(UNIT=unit_,TEXT=title)

!CEDRIC NOVEMBER 2011
    if(n1>1.and.n2>1)then
       WRITE(fmt_A,*) '(',n1-1,'(2x,',n2,'(I4,x)/),2x,',n2,'(I4,x))'
       WRITE(unit_,fmt_A) ((A(i1,i2),i2=1,n2),i1=1,n1)
    else
       WRITE(unit_,*) ((A(i1,i2),i2=1,n2),i1=1,n1)
    endif

    CALL flush(unit_)

  END SUBROUTINE 

!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************


  SUBROUTINE write_bool_array_rank_2(A,title,UNIT)

    !$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
    !$$ WRITE BOOLEAN ARRAY A(n1,n2) $$
    !$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

    CHARACTER(LEN=*),        INTENT(IN) :: title
    LOGICAL, DIMENSION(:,:), INTENT(IN) :: A
    INTEGER,       INTENT(IN), OPTIONAL :: UNIT
    INTEGER                             :: i1,i2,n1,n2,unit_
    CHARACTER(LEN=400)                  :: fmt_A

    unit_ = log_unit ! DEFAULT: STANDARD OUTPUT
    IF(PRESENT(UNIT)) unit_ = UNIT

    n1 = SIZE(A,1)
    n2 = SIZE(A,2)

    CALL dump_message(UNIT=unit_,TEXT=title)

!CEDRIC NOVEMBER 2011
    if(n1>1.and.n2>1)then
       WRITE(fmt_A,*) '(',n1-1,'(2x,',n2,'(L2,x)/),2x,',n2,'(L2,x))'
       WRITE(unit_,fmt_A) ((A(i1,i2),i2=1,n2),i1=1,n1)
    else
       WRITE(unit_,*) ((A(i1,i2),i2=1,n2),i1=1,n1)
    endif

    CALL flush(unit_)

  END SUBROUTINE 

!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************


  SUBROUTINE write_cplx_array_rank_1(A,title,UNIT,SHORT)

    !$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
    !$$ WRITE COMPLEX ARRAY A(n1) $$
    !$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

    CHARACTER(LEN=*),           INTENT(IN)  :: title
    COMPLEX(8), DIMENSION(:), INTENT(IN)    :: A
    LOGICAL,          INTENT(IN), OPTIONAL  :: SHORT
    INTEGER,          INTENT(IN), OPTIONAL  :: UNIT
    INTEGER                                 :: i1,n1,unit_
    LOGICAL                                 :: short_
    CHARACTER(LEN=400)                      :: fmt_A

    unit_ = log_unit ! DEFAULT: STANDARD OUTPUT
    IF(PRESENT(UNIT)) unit_ = UNIT

    short_ = present(short)

    n1 = SIZE(A)
    if(n1==1) return

    CALL dump_message(UNIT=unit_,TEXT=title)

   if(n1>0)then
    IF(short_)THEN
      WRITE(fmt_A,*)  '(',n1,'(2(a,f10.6),a,x))'
    ELSE
      WRITE(fmt_A,*)  '(',n1,'(2(a,f20.16),a,x))'
    ENDIF
    WRITE(unit_,fmt_A) ('(',DBLE(A(i1)),',',AIMAG(A(i1)),')',i1=1,n1)
   endif

    CALL flush(unit_)
  END SUBROUTINE

!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************


  SUBROUTINE write_real_array_rank_1(A,title,UNIT,SHORT)

    !$$$$$$$$$$$$$$$$$$$$$$$$$$$$
    !$$ WRITE REAL ARRAY A(n1) $$
    !$$$$$$$$$$$$$$$$$$$$$$$$$$$$

    CHARACTER(LEN=*),        INTENT(IN) :: title
    REAL(8), DIMENSION(:), INTENT(IN)   :: A
    LOGICAL,       INTENT(IN), OPTIONAL :: SHORT
    INTEGER,       INTENT(IN), OPTIONAL :: UNIT
    INTEGER                             :: i1,n1,unit_
    LOGICAL                             :: short_
    CHARACTER(LEN=400)                  :: fmt_A

    unit_ = log_unit ! DEFAULT: STANDARD OUTPUT
    IF(PRESENT(UNIT)) unit_ = UNIT

    short_ = present(short)

    n1 = SIZE(A)

    if(n1==1) return

    CALL dump_message(UNIT=unit_,TEXT=title)

    IF(short_)THEN
      WRITE(fmt_A,*) '(',n1,'(f10.6,x))'
    ELSE
      WRITE(fmt_A,*) '(',n1,'(f20.16,x))'
    ENDIF
    WRITE(unit_,fmt_A) (A(i1),i1=1,n1)

    CALL flush(unit_)
  END SUBROUTINE 

!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************


  SUBROUTINE write_intg_array_rank_1(A,title,UNIT)

    !$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
    !$$ WRITE INTEGER ARRAY A(n1) $$
    !$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

    CHARACTER(LEN=*),      INTENT(IN) :: title
    INTEGER, DIMENSION(:), INTENT(IN) :: A
    INTEGER,     INTENT(IN), OPTIONAL :: UNIT
    INTEGER                           :: i1,n1,unit_
    CHARACTER(LEN=400)                :: fmt_A

    unit_ = log_unit ! DEFAULT: STANDARD OUTPUT
    IF(PRESENT(UNIT)) unit_ = UNIT

    n1 = SIZE(A)
    if(n1==1) return

    CALL dump_message(UNIT=unit_,TEXT=title)

    WRITE(fmt_A,*) '(2x,',n1,'(I2,x))'
    WRITE(unit_,fmt_A) (A(i1),i1=1,n1)

    CALL flush(unit_)
  END SUBROUTINE 

!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************


  SUBROUTINE write_bool_array_rank_1(A,title,UNIT)

    !$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
    !$$ WRITE BOOLEAN ARRAY A(n1) $$
    !$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

    CHARACTER(LEN=*),      INTENT(IN) :: title
    LOGICAL, DIMENSION(:), INTENT(IN) :: A
    INTEGER,     INTENT(IN), OPTIONAL :: UNIT
    INTEGER                           :: i1,n1,unit_
    CHARACTER(LEN=400)                :: fmt_A

    unit_ = log_unit ! STANDARD OUTPUT
    IF(PRESENT(UNIT)) unit_ = UNIT

    n1 = SIZE(A)
    if(n1==1) return

    CALL dump_message(UNIT=unit_,TEXT=title)

    WRITE(fmt_A,*) '(2x,',n1,'(L2,x))'
    WRITE(unit_,fmt_A) (A(i1),i1=1,n1)

    CALL flush(unit_)

  END SUBROUTINE


!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
!**************************************************************************
